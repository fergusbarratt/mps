from fMPS import fMPS
from spin import N_body_spins, spins, spinHamiltonians
from numpy import array, linspace, real as re, reshape, sum, swapaxes
from numpy import tensordot as td, trace as tr, expand_dims as ed
from numpy import tensordot as td, squeeze as sq, swapaxes as sw
from numpy import transpose as tra, allclose
from numpy import linspace, prod, ones_like
from numpy.random import rand
from tensor import C as c
import matplotlib.pyplot as plt
from functools import reduce
from scipy.sparse.linalg import aslinearoperator, LinearOperator
from scipy.linalg import expm, qr, rq
from numpy.linalg import qr as qr_n, norm
from expokitpy import zgexpv, zhexpv
import scipy as sp
from copy import deepcopy
Sx, Sy, Sz = spins(0.5)
Sx1, Sy1, Sz1 = N_body_spins(0.5, 1, 2)
Sx2, Sy2, Sz2 = N_body_spins(0.5, 2, 2)

def lanczos_expm(A, v, t, norm_est=1., m=5, tol=0., trace=False, A_is_Herm=False):
    ideg = 6
    #Override expokit default precision to match scipy sparse eigs more closely.
    if tol == 0:
        tol = sp.finfo(sp.complex128).eps * 2 #cannot take eps, as expokit changes this to sqrt(eps)!

    xn = A.shape[0]
    vf = sp.ones((xn,), dtype=A.dtype)

    m = min(xn - 1, m)

    nwsp = max(10, xn * (m + 2) + 5 * (m + 2)**2 + ideg + 1)
    wsp = sp.zeros((nwsp,), dtype=A.dtype)

    niwsp = max(7, m + 2)
    iwsp = sp.zeros((niwsp,), dtype=sp.int32)

    iflag = sp.zeros((1,), dtype=sp.int32)
    itrace = sp.array([int(trace)])

    output_vec,tol0,iflag0 = zgexpv(m,t,v,tol,norm_est,wsp,iwsp,A.matvec,0)

    if iflag0 == 1:
        print("Max steps reached!")
    elif iflag0 == 2:
        print("Tolerance too high!")
    elif iflag0 < 0:
        print("Bad arguments!")
    elif iflag0 > 0:
        print("Unknown error!")

    return output_vec

def TDVP(mps, T, H_):
    mps.right_canonicalise()
    dt = T[1]-T[0]
    out = []
    e = []
    L = mps.L
    d = mps.d
        
    # sweep
    def sweep(mps):
        def H(n):
            h = H_.reshape([2, 2]*L)
            AL = mps.data[:n-1]
            AR = mps.data[n:]
            if n==1:
                AR = sw(sq(reduce(lambda x, y: td(x, y, [-1, -2]), AR)), 0, 1) #(2, 2) (aux, spin)
                ALH = ed(h, 0) #(1, 2?, 2_, 2, 2) @ (2, 2_(sp)), [[2], [1]] (indexing is not backwards on the bottom)
                ALHAR = td(ALH, c(AR), [range(2, L-n+2), range(1, L-n+1)]) #(1, 2(sp), 2(sp), 2(sp), 2(aux, down))
                ALALHAR = ed(ALHAR, 0) #(1, 1, 2, 2, 2_(sp), 2(aux)) @ (2, 2_(sp)), [[4], [1]]
                Hn = td(ALALHAR, AR, [range(4, L-n+4), range(1, L-n+1)]) #(1(aux, down), 1(aux, up), 2(sp, down), 2(sp, up), 2(aux, down), 2(aux, up))
            elif n==L:
                AL = sq(reduce(lambda x, y: td(x, y, [-1, -2]), AL)) #(2, 2) (spin, aux)
                #(2_, 2, 2, 2), (2_, 2) [[0], [0]]
                ALH = td(c(AL), h, [range(n-1), range(n-1)]) #(2(aux), 2(sp), 2(sp), 2(sp))
                ALHAR = ed(ALH, -1) #(2, 2, 2, 2, 1)
                #(2_, 2), (2, 2, 2, 2_, 1), [[0], [3]]
                ALALHAR = sw(td(AL, ALHAR, [range(n-1), range(3, n+2)]), 0, 1) # (2(aux, down), 2(aux, up), 2(sp, down), 2(sp, up), 1(aux), 1(aux))
                Hn = ed(ALALHAR, -1)
            else:
                AL = sq(reduce(lambda x, y: td(x, y, [-1, -2]), AL))
                AR = sw(sq(reduce(lambda x, y: td(x, y, [-1, -2]), AR)), 0, 1)
                ALH = td(c(AL), h, [range(n-1), range(n-1)])
                ALHAR = td(ALH, c(AR), [range(2, L-n+2), range(1, L-n+1)])
                ALALHAR = td(AL, ALHAR, [range(n-1), range(3, n+2)])
                Hn = td(ALALHAR, AR, [range(4, L-n+4), range(1, L-n+1)])

            return Hn

        def Hmv(n, v):
            AC = v.reshape(mps.data[n-1].shape)
            return td(H(n), AC, [[1, 3, 5], [1, 0, 2]]).reshape(v.shape)

        def Kmv(n, v):
            C = v.reshape((mps.data[n-1].shape[-1], -1))
            #(dl, ur, dr, ul), (ur, ul) (ul-urCul-ur)
            return td(K(n), C, [[1, 3], [1, 0]]).reshape(v.shape)

        def H_op(n):
            S = H(n).shape
            return LinearOperator((S[0]*S[2]*S[4], S[0]*S[2]*S[4]), 
                                  lambda v: Hmv(n, v))

        def K(n):
            #td(H(n).shape, mps.data[n-1].shape), [[3, 1], [0, 1]]) (1, 1_, 2, 2_, 2, 2), (2_, 1_, 2): 
            #(2_, 1_, 2), (1_(aux, dl), 2_(sp, d), 2(aux, ur), 2(aux, dr), 2(aux, ul))
            #(2(aux, dl), 2(aux, ur), 2(aux, dr), 2(aux, ul))
            return td(c(mps.data[n-1]), td(H(n), mps.data[n-1], [[3, 1], [0, 1]]), [[0, 1], [1, 0]])

        def K_op(n):
            S = K(n).shape
            return LinearOperator((S[0]*S[1], S[0]*S[1]),
                                  lambda v: Kmv(n, v))

            C_new = array([[1]])

        C_new = array([[1]])
        for n, A in enumerate(mps.data):
            n = n+1
            #print(n)
            f = 2 if n == len(mps.data) else 1
            #A_new = lanczos_expm(-1j*H_op(n), (C_new@A).reshape(H_op(n).shape[0]), dt*f/2).reshape(A.shape)
            AC_new = (expm(-f*1j*dt/2*(tra(H(n), [0, 2, 4, 1, 3, 5]).reshape(H_op(n).shape)))@((C_new@A).reshape(H_op(n).shape[0]))).reshape(A.shape)
            q, C = qr(AC_new.reshape((prod(AC_new.shape[:2]), -1)), mode='economic')
            #print(norm(mps.data[n-1]-q.reshape(A_new.shape)))
            mps.data[n-1] = q.reshape(AC_new.shape)
            from tests import is_right_canonical, is_left_canonical
            print(sum(c(mps.data)[n-1]@mps.data[n-1], axis=0)
            print(n)
            #print(is_left_canonical(mps.data[:n-1], error=True))
            #print(is_right_canonical(mps.data[n-1:], error=True))
            #print(is_left_canonical(mps.data, error=True))
            #print(is_right_canonical(mps.data, error=True))


            if n != len(mps.data):
                #C_new = lanczos_expm(1j*K_op(n), C.reshape(K_op(n).shape[0]), dt/2).reshape(C.shape) 
                C_new = (((expm(1j*dt/2*tra(K(n), [0, 2, 3, 1]).reshape(K_op(n).shape))@(C.reshape(K_op(n).shape[0])))).reshape(C.shape))

        #for n, A in list(enumerate(mps.data))[::-1][1:]:
        #    n = n+1
        #    #print(n)
        #    C, q = rq(tra(A, [1, 0, 2]).reshape((A.shape[1], -1)), mode='economic')
        #    #print(norm(mps.data[n]-tra(A_new, [1, 0, 2])))
        #    mps.data[n] = tra(A_new, [1, 0, 2])
        #    if n != 1:
        #        #C_new = lanczos_expm(1j*K_op(n-1), C.reshape(K_op(n-1).shape[0]), dt/2).reshape(C.shape) 
        #        C_new = (((expm(1j*dt/2*tra(K(n-1), [0, 2, 3, 1]).reshape(K_op(n-1).shape))@(C.reshape(K_op(n-1).shape[0])))).reshape(C.shape))
        #    #A_new = lanczos_expm(-1j*H_op(n), (A@C_new).reshape(H_op(n).shape[0]), dt/2).reshape(tra(A, [1, 0, 2]).shape)
        #    A_new = (expm(-1j*dt/2*(tra(H(n), [0, 2, 4, 1, 3, 5]).reshape(H_op(n).shape)))@((A@C_new).reshape(H_op(n).shape[0]))).reshape(A.shape)
        #return mps
        
    from copy import copy
    for _ in T:
        out.append([mps.E(Sx, 0), mps.E(Sy, 0), mps.E(Sz, 0)])
        mps = mps.right_canonicalise()
        sweep(mps)

    return array(out)

mps_0 = fMPS().random(2, 2, 20).right_canonicalise()
psi_0 = mps_0.recombine().reshape(-1)
T = linspace(0, 1, 1000)
H = spinHamiltonians(0.5, 2).TFIM(10)
Tra = TDVP(mps_0, T, H)
print(Tra.shape)
fig, ax = plt.subplots(3, 1)
ax[0].plot([c(psi_0)@expm(1j*t*H)@Sx1@expm(-1j*t*H)@psi_0 for t in T])
ax[0].plot(Tra[:, 0])
ax[1].plot([c(psi_0)@expm(1j*t*H)@Sy1@expm(-1j*t*H)@psi_0 for t in T])
ax[1].plot(Tra[:, 1])
ax[2].plot([c(psi_0)@expm(1j*t*H)@Sz1@expm(-1j*t*H)@psi_0 for t in T])
ax[2].plot(Tra[:, 2])
ax[0].set_ylim([-1, 1])
ax[1].set_ylim([-1, 1])
ax[2].set_ylim([-1, 1])
plt.show()
